#!/usr/bin/env python3
import asyncio
import os
import sys
import random
import logging
import yaml
import shutil

from pyrevolve.custom_logging import logger
from pyrevolve import parser
from pyrevolve.SDF.math import Vector3
from pyrevolve.tol.manage import World
from pyrevolve.evolution.individual import Individual
from pyrevolve.genotype.plasticoding.crossover.crossover import CrossoverConfig
from pyrevolve.genotype.plasticoding.crossover.standard_crossover import standard_crossover
from pyrevolve.genotype.plasticoding.initialization import random_initialization
from pyrevolve.genotype.plasticoding.mutation.mutation import MutationConfig
from pyrevolve.genotype.plasticoding.mutation.standard_mutation import standard_mutation
from pyrevolve.genotype.plasticoding.plasticoding import PlasticodingConfig
from pyrevolve.revolve_bot.brain import BrainRLPowerSplines
from pyrevolve.util.supervisor.supervisor_multi import DynamicSimSupervisor

ROBOT_BATTERY = 5000
INDIVIDUAL_MAX_AGE = 60  # 5 minutes
SEED_POPULATION_START = 30
MIN_POP = 20
MAX_POP = 300
Z_SPAWN_DISTANCE = 0.5
LIMIT_X = 5
LIMIT_Y = 5
MATURE_AGE = 60
MATE_DISTANCE = 0.6
MATING_COOLDOWN = 60
COUPLE_MATING_LIMIT = 5

PLASTICODING_CONF = PlasticodingConfig()
CROSSOVER_CONF = CrossoverConfig(crossover_prob=1.0)
MUTATION_CONF = MutationConfig(mutation_prob=0.8, genotype_conf=PLASTICODING_CONF)
DATA_FOLDER_BASE = os.path.dirname(os.path.realpath(__file__))


def make_folders(base_dirpath):

    assert(os.path.isdir(base_dirpath))
    counter = 0
    while True:
        dirpath = os.path.join(base_dirpath, str(counter))
        if not os.path.exists(dirpath):
            break
        counter += 1

    print(f"CHOSEN EXPERIMENT FOLDER {dirpath}")

    # if os.path.exists(dirpath):
    #     shutil.rmtree(dirpath)
    os.mkdir(dirpath)
    os.mkdir(dirpath+'/genotypes')
    os.mkdir(dirpath+'/phenotypes')
    os.mkdir(dirpath+'/descriptors')

    return dirpath


class OnlineIndividual(Individual):
    def __init__(self, genotype):
        super().__init__(genotype)
        self.manager = None

    @staticmethod
    def clone_from(other):
        self = OnlineIndividual(other.genotype)
        self.phenotype = other.phenotype
        self.manager = other.manager
        self.fitness = other.fitness
        self.parents = other.parents

    def develop(self):
        super().develop()
        # self.phenotype._brain = BrainRLPowerSplines(evaluation_rate=10.0)

    def age(self):
        return self.manager.age()

    def charge(self):
        return self.manager.charge()

    def pos(self):
        return self.manager.last_position

    def starting_position(self):
        return self.manager.starting_position

    def distance_to(self, other, planar: bool = True):
        """
        Calculates the Euclidean distance from this robot to
        the given vector position.
        :param other: Target for measuring distance
        :type other: Vector3|OnlineIndividual
        :param planar: If true, only x/y coordinates are considered.
        :return: distance to other
        :rtype: float
        """
        my_pos = self.pos()
        other_pos = other if isinstance(other, Vector3) else other.pos()

        diff = my_pos - other_pos
        if planar:
            diff.z = 0

        return diff.norm()

    def mature(self):
        return self.age() > MATURE_AGE

    def _wants_to_mate(self, other):
        if not self.mature():
            return False

        if self.distance_to(other) > MATE_DISTANCE:
            return False

        if self.manager.last_mate is not None and \
                float(self.manager.last_update - self.manager.last_mate) < MATING_COOLDOWN:
            return False

        mate_count = self.manager.mated_with.get(other.manager.name, 0)
        if mate_count > COUPLE_MATING_LIMIT:
            return False

        return True

    def mate(self, other):
        """
        Will try to mate with other
        :param other: potential mate
        :type other: OnlineIndividual
        :return: Genotype generated by the mating process, None if no mating happened
        :rtype: Genotype|None
        """
        if not (self._wants_to_mate(other) and other._wants_to_mate(self)):
            return None

        # save the mating
        self.manager.last_mate = self.manager.last_update
        if other.manager.name in self.manager.mated_with:
            self.manager.mated_with[other.manager.name] += 1
        else:
            self.manager.mated_with[other.manager.name] = 1

        genotype = standard_crossover([self.genotype, other.genotype], PLASTICODING_CONF, CROSSOVER_CONF)
        genotype = standard_mutation(genotype, MUTATION_CONF)

        return OnlineIndividual(genotype)

    def export_life_data(self, folder):
        life = {
            'starting_time': float(self.manager.starting_time),
            'age': float(self.age()),
            'charge': self.charge(),
            'start_pos': str(self.starting_position()),
            'last_pos': str(self.pos()),
            'avg_orientation': str(Vector3(self.manager.avg_roll, self.manager.avg_pitch, self.manager.avg_yaw)),
            'avg_pos': str(Vector3(self.manager.avg_x, self.manager.avg_y, self.manager.avg_z)),
            'last_mate': str(self.manager.last_mate),
        }

        with open(f'{folder}/life_{self.id}.yaml', 'w') as f:
            f.write(str(yaml.dump(life)))

    def export(self, folder):
        self.export_genotype(folder)
        self.export_phenotype(folder)
        self.export_life_data(folder)

    def __repr__(self):
        _id = None
        if self.phenotype is not None:
            _id = self.phenotype.id
        elif self.genotype.id is not None:
            _id = self.genotype.id
        return f'Individual_{_id}({self.age()}, {self.charge()}, {self.pos()})'


def random_spawn_pos():
    return Vector3(
        random.uniform(-LIMIT_X, LIMIT_X),
        random.uniform(-LIMIT_Y, LIMIT_Y),
        Z_SPAWN_DISTANCE
    )


def is_pos_occupied(pos, robots, distance):
    for robot in robots:
        if robot.distance_to(pos) < distance:
            return True

    return False


def free_random_spawn_pos(robots, distance=MATE_DISTANCE+0.1):
    pos = random_spawn_pos()
    while is_pos_occupied(pos, robots, distance):
        pos = random_spawn_pos()

    return pos


async def insert_robot(world, robot, pos):
    robot.update_substrate()
    robot.battery_level = ROBOT_BATTERY
    await (await world.delete_model(robot.id))

    # Insert the robot in the simulator
    insert_future = await world.insert_robot(robot, pos)
    robot_manager = await insert_future
    return robot_manager


async def insert_individual(world, individual, pos, data_folder):
    individual.develop()
    individual.manager = await insert_robot(world, individual.phenotype, pos)
    individual.export(data_folder)
    return individual


async def remove_individual(world, individual, data_folder):
    individual.export(data_folder)
    await world.delete_robot(individual.manager)


async def generate_insert_random_robot(world, _id, robots, data_folder):
    # Load a robot from yaml
    genotype = random_initialization(PLASTICODING_CONF, _id)
    individual = OnlineIndividual(genotype)
    return await insert_individual(world, individual, free_random_spawn_pos(robots), data_folder)


async def mating_season(world, log, robots, robot_counter, data_folder):
    class BreakIt(Exception):
        pass
    try:
        if len(robots) > MAX_POP:
            raise BreakIt
        for individual1 in robots:
            if not individual1.mature():
                continue
            for individual2 in robots:
                if len(robots) > MAX_POP:
                    raise BreakIt
                if individual1 is individual2:
                    continue

                individual3 = individual1.mate(individual2)
                if individual3 is None:
                    continue

                robot_counter += 1
                individual3.genotype.id = robot_counter

                # pos3 = (individual1.pos() + individual2.pos())/2
                # pos3.z = Z_SPAWN_DISTANCE
                pos3 = free_random_spawn_pos(robots)

                robots.append(individual3)
                await insert_individual(world, individual3, pos3, data_folder)
                log.info(f"MATE!!!! between {individual1} and {individual2} generated {individual3}")

    except BreakIt:
        pass

    return robot_counter


async def run():
    robot_counter = 0
    data_folder = make_folders(DATA_FOLDER_BASE)
    log = logger.create_logger('experiment', handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler(os.path.join(data_folder, 'experiment_manager.log'), mode='w')
    ])

    # Parse command line / file input arguments
    settings = parser.parse_args()

    # Start Simulator
    if settings.simulator_cmd != 'debug':
        simulator_supervisor = DynamicSimSupervisor(
            world_file=settings.world,
            simulator_cmd=settings.simulator_cmd,
            simulator_args=["--verbose"],
            plugins_dir_path=os.path.join('.', 'build', 'lib'),
            models_dir_path=os.path.join('.', 'models'),
            simulator_name='gazebo'
        )
        await simulator_supervisor.launch_simulator(port=settings.port_start)

    # Connect to the simulator and pause
    world = await World.create(settings, world_address=('127.0.0.1', settings.port_start))
    await asyncio.sleep(1)

    robots = []

    log.info("SEEDING POPULATION STARTED")
    await world.pause(True)
    while len(robots) < SEED_POPULATION_START:
        robot_counter += 1
        individual = await generate_insert_random_robot(world, robot_counter, robots, data_folder)
        log.info(f"LOW REACHED: inserting new random robot: {individual}")
        robots.append(individual)
    await world.pause(False)
    log.info("SEEDING POPULATION FINISHED")

    # Start a run loop to do some stuff
    while True:
        # Print robot fitness every second
        for individual in robots:
            # log.info(f"{individual} "
            #          f"battery {individual.manager.charge()} "
            #          f"age {individual.manager.age()} "
            #          f"fitness is {fitness.online_old_revolve(individual.manager)}")
            if individual.age() > INDIVIDUAL_MAX_AGE:
                log.info(f"ROBOT DIES OF OLD AGE: {individual}")
                robots.remove(individual)
                await remove_individual(world, individual, data_folder)

        robot_counter = await mating_season(world, log, robots, robot_counter, data_folder)

        while len(robots) < MIN_POP:
            robot_counter += 1
            individual = await generate_insert_random_robot(world, robot_counter, robots, data_folder)
            log.info(f"LOW REACHED: inserting new random robot: {individual}")
            robots.append(individual)

        # if len(robot_managers) == 0:
            #     log.info("Robot population got extended")
            #     return

        await asyncio.sleep(0.05)
